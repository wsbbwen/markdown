# 苍穹外卖项目技术总结

## 1. 项目简介
示例：
> 苍穹外卖是一个外卖点餐系统，包含员工管理、菜品管理、套餐、订单、用户登录等功能。
> 后端采用 Spring Boot + MyBatis + Redis + MySQL，多处业务使用缓存、拦截器、AOP 等技术。

---

## 2. 项目整体结构
### 2.1 后端分层结构
- **Controller：** 接收请求、参数校验、调用 service、返回统一结果
- **Service：** 业务逻辑处理
- **Mapper：** 持久层操作（CRUD）
- **Entity：** 数据库表实体
- **DTO：** Controller 接收参数使用（与 Entity 分离）
- **VO：** 返回给前端的数据封装

你可以补充对每层的理解。

---

## 3. 项目用到的核心技术点（总览）
把你会的技术全部列出来：

- Spring Boot
- MyBatis 
- MySQL
- Redis 缓存
- JWT 登录认证
- 全局异常处理
- 拦截器（HandlerInterceptor）
- AOP 自动填充字段、日志
- 自定义注解 + 注解解析
- HTTPClient 调用微信接口
- 阿里云 OSS 文件上传
- WebSocket 实时订单推送
- Spring Task 定时任务
- Spring Cache 缓存注解
- ThreadLocal 保存当前用户
- 统一返回结果封装（Result）
- 分页查询（PageHelper）
- Swagger / Knife4j 接口文档
- YAML 配置注入（@ConfigurationProperties）

---

## 4. 核心功能与关键技术详解

### 4.1.JWT（登录校验核心机制）

#### 4.1.1  JWT 是什么？

JWT 就像一个**“防伪学生证”**，你登录成功后，服务器给你发一张证。
 你之后来访问食堂、图书馆（接口）时，只要出示学生证（token），学校就知道：

- 你是谁（用户 ID）
- 证是不是伪造的（签名）
- 证有没有过期（过期时间）

#### 4.1.2 JWT 的三部分结构

一个 JWT 由三部分组成：

```css
Header.Payload.Signature
```

可以理解为：

| 部分      | 中文 | 作用                                |
| --------- | ---- | ----------------------------------- |
| Header    | 头部 | 说明“我是什么类型 + 用什么算法签名” |
| Payload   | 载荷 | 你真正想放的数据（比如用户 id）     |
| Signature | 签名 | 防伪印章，证明没有被篡改            |

---

#### 4.1.3 yml 配置（非常重要）

```yml
jwt:
  admin-secret-key: itcast          # 服务器用来“盖章”的密钥
  admin-ttl: 720000000             # 过期时间（毫秒）
  admin-token-name: token          # 前端把 token 放在请求头时的字段名
```

#### 4.1.4 properties 类（把 yml 映射成 Java）

```java
@Component
@ConfigurationProperties(prefix = "sky.jwt")
@Data
public class JwtProperties {

    private String adminSecretKey;
    private long adminTtl;
    private String adminTokenName;
}
```

yml 是“配置文件”，
 properties 是“把配置读进 Java 的盒子”。
 后面其他类都可以拿这个盒子里的数据。

#### 4.1.5 如何生成 Token（createJWT）

##### 第 1 步：准备要写进 token 的数据（claims）

比如登录管理员：

```java
Map<String, Object> claims = new HashMap<>();
claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
```

> claims = “我要写进学生证上的内容”。

------

##### 第 2 步：计算 token 什么时候过期

```java
long expMillis = System.currentTimeMillis() + ttlMillis;
Date exp = new Date(expMillis);
```

> 相当于“学生证有效期一学期”。

------

##### 第 3 步：签名算法

```java
SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;
```

>  HS256 就像“压印机器”，印章不一样，别人就无法伪造。

#### 4.1.6 createJWT 的完整代码

```java
public static String createJWT(String secretKey, long ttlMillis, Map<String, Object> claims) {

    // 1. 签名算法：HS256（对称加密）
    SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;

    // 2. 当前时间
    long nowMillis = System.currentTimeMillis(); 
    Date now = new Date(nowMillis);
    
    // 3. 计算过期时间 
    Date exp = new Date(nowMillis + ttlMillis);

    // 4. 开始创建 token
    return Jwts.builder()
       		// 设置私有内容（你往 token 塞的数据）
            .setClaims(claims)
        	// 设置签发时间（iat）
            .setIssuedAt(now)
        	// 设置过期时间（exp）
            .setExpiration(exp)
        	// 用密钥 + 算法 进行签名盖章
            .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))
        	// 5. 压缩成最终字符串
            .compact();
}
```





### 4.2 登录拦截器
#### 4.2.1 为什么需要拦截器？

它就像学校大门的保安：

- 你没带“学生证”（token）→ 不让进
- 你学生证是假的 → 不让进
- 你学生证过期了 → 不让进
- 你学生证是真的 → 通过

---

#### 4.2.2 拦截哪些路径？

在 WebMvcConfiguration 里配置：

```java
registry.addInterceptor(loginCheckInterceptor)
        .addPathPatterns("/admin/**")
        .excludePathPatterns("/admin/employee/login");
```

>  **addPathPatterns**：要检查的门
>  **excludePathPatterns**：不用检查的门（白名单）

#### 4.2.3 拦截器的执行顺序

```java
请求进入 → preHandle()
    如果 false → 直接返回，不进入 Controller
    如果 true → 继续执行 Controller
               ↓
Controller 调用完毕
               ↓
postHandle()
               ↓
afterCompletion()   // 收尾清理
```

#### 4.2.4 parseJWT（验证 token）

```java
public static Claims parseJWT(String secretKey, String token) {
    return Jwts.parser()
            .setSigningKey(secretKey.getBytes(StandardCharsets.UTF_8))
            .parseClaimsJws(token)
            .getBody();
}
```

#### 4.2.5 完整版拦截器

```java
@Component
@Slf4j
public class JwtTokenAdminInterceptor implements HandlerInterceptor {
    @Autowired
    private JwtProperties jwtProperties;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        // 1. 如果不是访问 Controller 方法（Static Resource），直接放行
        if (!(handler instanceof HandlerMethod)) {
            return true;
        }

        // 2. 从请求头获取 token
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        try {
            log.info("JWT 校验开始, token = {}", token);

            // 3. 校验 token
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);

            // 4. 将 employeeId 放入 ThreadLocal（后续业务需要它）
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            BaseContext.setCurrentId(empId);

            log.info("当前登录员工 id：{}", empId);

            return true; // 放行

        } catch (Exception e) {
            // token 无效
            response.setStatus(401);
            return false;
        }
    }
}
```
### 4.3 AOP（自动填充字段、统一日志）
- 自动填充 createTime / updateTime / createUser / updateUser

- 使用 @Aspect 实现横切逻辑

- 在哪里触发？

  触发点 → **Mapper 的 Insert / Update 方法执行前**

  流程图如下：

  ```java
  Controller -> Service -> Mapper.insert(entity)
                                   ↑
                                 @AutoFill
                               AOP 自动填充
  ```

  也就是说：

  ✔ 用户发请求 →
   ✔ Service 调用 Mapper →
   ✔ Mapper 上的方法带注解 @AutoFill(INSERT/UPDATE) →
   ✔ 触发 AOP →
   ✔ 自动给实体对象 set 时间、set 用户

- 为什么不用每次都在 service 手写？

  使用 AOP 后：

  ✔ 统一管理
   ✔ Mapper 方法自动增强
   ✔ 业务逻辑更干净
   ✔ 可扩展性强（后续你再想加字段也方便）

---

### 4.4 自定义注解 + 自己实现 Bean
写：
- 如何写一个注解 @AutoFill

  注解本质就是一个“标记”，告诉 AOP 哪些方法要增强。

  AutoFill.java

  ```java
  @Target(ElementType.METHOD)      // 注解放在方法上
  @Retention(RetentionPolicy.RUNTIME)  // 运行时生效
  public @interface AutoFill {
  
      OperationType value();   // INSERT or UPDATE
  }
  ```

  OperationType.java

  ```java
  public enum OperationType {
      INSERT,
      UPDATE
  }
  ```

  

- 如何写一个解析器处理注解

  其实解析器不单独写成 Bean，而是**在切面中读取注解信息 + 使用反射来填充字段**。

  但很多公司会拆成 Bean，这样更专业：

  ```java
  @Component
  public class AutoFillResolver {
  
      public void fill(OperationType type, Object entity) {
          LocalDateTime now = LocalDateTime.now();
          Long userId = BaseContext.getCurrentId();
  
          try {
              if (type == OperationType.INSERT) {
                  entity.getClass().getDeclaredMethod("setCreateTime", LocalDateTime.class)
                          .invoke(entity, now);
                  entity.getClass().getDeclaredMethod("setCreateUser", Long.class)
                          .invoke(entity, userId);
              }
  
              entity.getClass().getDeclaredMethod("setUpdateTime", LocalDateTime.class)
                      .invoke(entity, now);
              entity.getClass().getDeclaredMethod("setUpdateUser", Long.class)
                      .invoke(entity, userId);
  
          } catch (Exception e) {
              throw new RuntimeException(e);
          }
      }
  }
  ```

  这就是一个**反射填充机器**。

- 如何实现切面中扫描注解

  AutoFillAspect.java

  ```java
  @Aspect
  @Component
  public class AutoFillAspect {
  
      @Autowired
      private AutoFillResolver autoFillResolver;
  
      @Before("@annotation(autoFill)")  // 扫描带注解的方法
      public void fillFields(JoinPoint joinPoint, AutoFill autoFill) {
  
          OperationType type = autoFill.value(); // 解析注解中的 type
  
          // 获取 Mapper 方法的第一个参数（一般是实体对象）
          Object entity = joinPoint.getArgs()[0];
  
          autoFillResolver.fill(type, entity);
      }
  }
  ```

- 注解增强了哪些方法（Insert / Update）

- 学会了什么叫元注解（@Target/@Retention）

---

### 4.5 Redis 缓存（菜品、套餐、营业状态）
你可以写以下重点：
- 为什么要使用 Redis？
- 缓存哪些数据？
- 使用哪些数据结构？（String / List）
- 什么时候清缓存？
- Redis 在整个项目中的作用总结

---

### 4.6 Spring Cache
写：
- @Cacheable
- @CacheEvict
- @CachePut  
以及：
- 缓存 key 如何生成
- 为什么部分模块用 Spring Cache 而不是手写 Redis 代码？

---

### 4.7 HTTPClient 调用微信 API
写：
- 用于微信登录（拿 code → 换 openid）
- 为什么不用 Feign？
- 如何使用 HttpClient 发送 GET 请求？
- API 返回的数据如何解析？

---

### 4.8 阿里云 OSS（文件上传）
写：
- 为什么要使用云存储而不是本地？
- 如何生成上传路径？
- 文件如何防止重名？
- 上传成功后返回 URL 给前端

---

### 4.9 WebSocket 实时订单推送
写：
- 用来给商家推订单提醒
- 订单创建后推消息给前端
- WebSocket 与 HTTP 有什么区别？

---

### 4.10 全局异常处理
写：
- @ControllerAdvice + @ExceptionHandler
- 统一处理：业务异常、SQL 异常、操作失败
- 好处：简化 controller，让返回结构统一

---

### 4.11 CRUD 实现逻辑总结
把你熟悉的 “增删改查模板” 写下来：
- Controller 接收参数
- 调 service
- 调 mapper
- 返回 Result.ok()

写一段自己的模板代码或者流程图，非常有用。

---

### 4.12 分页查询（PageHelper）
写：
- PageHelper.startPage
- Page 对象结构（total + list）
- 为什么要分页？

---

### 4.13 定时任务（Spring Task）
写：
- 每天 1 点处理过期订单
- cron 表达式
- @Scheduled 怎么用？

---

### 4.14 配置属性注入（@ConfigurationProperties）
写：
- 用来注入 OSS、jwt、wechat 配置
- prefix 配置如何生效？
- 为什么不用 @Value？

---

## 5. 我对项目整体的理解

你总结学到的几个“关键思想”：
- 分层思想
- 业务与持久层解耦
- 异常统一处理
- 登录状态无状态化
- 通过缓存提升性能
- AOP 减少重复代码

给你一句能写进去的总结：

> 学完后最大的收获是：开始理解“框架是为了减少重复代码、统一流程、提高可维护性”，不像以前只是写 CRUD。

---

## 6. 项目中我仍然模糊的部分（问题列表）
这一段非常重要，把你不太明白的写出来：

示例：
- ThreadLocal 为什么必须在线程结束后清理？
- Redis 缓存什么时候会失效？
- JWT 为什么能避免 session？
- AOP 如何做到在方法执行前后织入逻辑？
- WebSocket 的连接是如何保持的？
- 拦截器和过滤器区别？

你写出来我可以帮你逐条讲。

---

## 7. 后续想要补强的技能计划
你可以写：

- [ ] 自己从零写一次分类模块（不用看视频）
- [ ] 自己重新写一遍登录模块（jwt + interceptor）
- [ ] 手动实现一个简单的 Redis 缓存逻辑
- [x] 用 Markdown 写一篇业务流程总结
- [ ] 复刻一次套餐业务（复杂度高）

---

## 8. 总结（随便写）
例如：

> 这个项目是我接触到的第一个完整商业级后端项目，通过它我掌握了很多框架底层思想，也知道自己还需要补哪些能力。接下来会复盘 + 二刷，把知识真正吃透。